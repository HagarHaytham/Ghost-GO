/*!
 * @pixi/filter-motion-blur - v3.0.3
 * Compiled Wed, 29 May 2019 03:04:05 UTC
 *
 * @pixi/filter-motion-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Filter } from '@pixi/core';
import { Point, ObservablePoint } from '@pixi/math';

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n";

/**
 * The MotionBlurFilter applies a Motion blur to an object.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/motion-blur.png)
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-motion-blur|@pixi/filter-motion-blur}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 * @param {PIXI.ObservablePoint|PIXI.Point|number[]} [velocity=[0, 0]] Sets the velocity of the motion for blur effect.
 * @param {number} [kernelSize=5] - The kernelSize of the blur filter. Must be odd number >= 5
 * @param {number} [offset=0] - The offset of the blur filter.
 */
var MotionBlurFilter = /*@__PURE__*/(function (Filter) {
    function MotionBlurFilter(velocity, kernelSize, offset) {
        if ( velocity === void 0 ) velocity = [0, 0];
        if ( kernelSize === void 0 ) kernelSize = 5;
        if ( offset === void 0 ) offset = 0;

        Filter.call(this, vertex, fragment);
        this.uniforms.uVelocity = new Float32Array(2);
        this._velocity = new ObservablePoint(this.velocityChanged, this);
        this.velocity = velocity;

        /**
         * The kernelSize of the blur, higher values are slower but look better.
         * Use odd value greater than 5.
         * @member {number}
         * @default 5
         */
        this.kernelSize = kernelSize;
        this.offset = offset;
    }

    if ( Filter ) MotionBlurFilter.__proto__ = Filter;
    MotionBlurFilter.prototype = Object.create( Filter && Filter.prototype );
    MotionBlurFilter.prototype.constructor = MotionBlurFilter;

    var prototypeAccessors = { velocity: { configurable: true },offset: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    MotionBlurFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        var ref = this.velocity;
        var x = ref.x;
        var y = ref.y;

        this.uniforms.uKernelSize = (x !== 0 || y !== 0) ? this.kernelSize : 0;
        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * Sets the velocity of the motion for blur effect.
     *
     * @member {PIXI.ObservablePoint}
     */
    prototypeAccessors.velocity.set = function (value) {
        if (Array.isArray(value)) {
            this._velocity.set(value[0], value[1]);
        }
        else if (value instanceof Point || value instanceof ObservablePoint) {
            this._velocity.copy(value);
        }
    };

    prototypeAccessors.velocity.get = function () {
        return this._velocity;
    };

    /**
     * Handle velocity changed
     * @private
     */
    MotionBlurFilter.prototype.velocityChanged = function velocityChanged () {
        this.uniforms.uVelocity[0] = this._velocity.x;
        this.uniforms.uVelocity[1] = this._velocity.y;
    };

    /**
     * The offset of the blur filter.
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.offset.set = function (value) {
        this.uniforms.uOffset = value;
    };

    prototypeAccessors.offset.get = function () {
        return this.uniforms.uOffset;
    };

    Object.defineProperties( MotionBlurFilter.prototype, prototypeAccessors );

    return MotionBlurFilter;
}(Filter));

export { MotionBlurFilter };
//# sourceMappingURL=filter-motion-blur.esm.js.map
