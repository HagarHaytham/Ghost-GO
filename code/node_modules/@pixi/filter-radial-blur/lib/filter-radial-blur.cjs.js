/*!
 * @pixi/filter-radial-blur - v3.0.3
 * Compiled Wed, 29 May 2019 03:04:05 UTC
 *
 * @pixi/filter-radial-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@pixi/core');

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n";

/**
 * The RadialBlurFilter applies a Motion blur to an object.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/radial-blur.png)
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-radial-blur|@pixi/filter-radial-blur}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 * @param {number} [angle=0] Sets the angle of the motion for blur effect.
 * @param {PIXI.Point|number[]} [center=[0,0]] The center of the radial.
 * @param {number} [kernelSize=5] - The kernelSize of the blur filter. But be odd number >= 3
 * @param {number} [radius=-1] - The maximum size of the blur radius, `-1` is infinite
 */
var RadialBlurFilter = /*@__PURE__*/(function (Filter) {
    function RadialBlurFilter(angle, center, kernelSize, radius) {
        if ( angle === void 0 ) angle = 0;
        if ( center === void 0 ) center = [0, 0];
        if ( kernelSize === void 0 ) kernelSize = 5;
        if ( radius === void 0 ) radius = -1;

        Filter.call(this, vertex, fragment);

        this._angle = 0;
        this.angle = angle;
        this.center = center;
        this.kernelSize = kernelSize;
        this.radius = radius;
    }

    if ( Filter ) RadialBlurFilter.__proto__ = Filter;
    RadialBlurFilter.prototype = Object.create( Filter && Filter.prototype );
    RadialBlurFilter.prototype.constructor = RadialBlurFilter;

    var prototypeAccessors = { angle: { configurable: true },center: { configurable: true },radius: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    RadialBlurFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.uKernelSize = this._angle !== 0 ? this.kernelSize : 0;
        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * Sets the angle in degrees of the motion for blur effect.
     *
     * @member {PIXI.Point|number[]}
     * @default [0, 0]
     */
    prototypeAccessors.angle.set = function (value) {
        this._angle = value;
        this.uniforms.uRadian = value * Math.PI / 180;
    };

    prototypeAccessors.angle.get = function () {
        return this._angle;
    };

    /**
     * Center of the effect.
     *
     * @member {PIXI.Point|number[]}
     * @default [0, 0]
     */
    prototypeAccessors.center.get = function () {
        return this.uniforms.uCenter;
    };

    prototypeAccessors.center.set = function (value) {
        this.uniforms.uCenter = value;
    };

    /**
     * Outer radius of the effect. The default value of `-1` is infinite.
     *
     * @member {number}
     * @default -1
     */
    prototypeAccessors.radius.get = function () {
        return this.uniforms.uRadius;
    };

    prototypeAccessors.radius.set = function (value) {
        if (value < 0 || value === Infinity) {
            value = -1;
        }
        this.uniforms.uRadius = value;
    };

    Object.defineProperties( RadialBlurFilter.prototype, prototypeAccessors );

    return RadialBlurFilter;
}(core.Filter));

exports.RadialBlurFilter = RadialBlurFilter;
//# sourceMappingURL=filter-radial-blur.cjs.js.map
