/*!
 * @pixi/filter-drop-shadow - v3.0.3
 * Compiled Wed, 29 May 2019 03:04:05 UTC
 *
 * @pixi/filter-drop-shadow is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filterKawaseBlur = require('@pixi/filter-kawase-blur');
var core = require('@pixi/core');
var settings = require('@pixi/settings');
var math = require('@pixi/math');
var utils = require('@pixi/utils');

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Un-premultiply alpha before applying the color\n    if (sample.a > 0.0) {\n        sample.rgb /= sample.a;\n    }\n\n    // Premultiply alpha again\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}";

/**
 * Drop shadow filter.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/drop-shadow.png)
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-drop-shadow|@pixi/filter-drop-shadow}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 * @param {object} [options] Filter options
 * @param {number} [options.rotation=45] The angle of the shadow in degrees.
 * @param {number} [options.distance=5] Distance of shadow
 * @param {number} [options.color=0x000000] Color of the shadow
 * @param {number} [options.alpha=0.5] Alpha of the shadow
 * @param {number} [options.shadowOnly=false] Whether render shadow only
 * @param {number} [options.blur=2] - Sets the strength of the Blur properties simultaneously
 * @param {number} [options.quality=3] - The quality of the Blur filter.
 * @param {number[]} [options.kernels=null] - The kernels of the Blur filter.
 * @param {number|number[]|PIXI.Point} [options.pixelSize=1] - the pixelSize of the Blur filter.
 * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution of the Blur filter.
 */
var DropShadowFilter = /*@__PURE__*/(function (Filter) {
    function DropShadowFilter(options) {

        // Fallback support for ctor: (rotation, distance, blur, color, alpha)
        if (options && options.constructor !== Object) {
            // eslint-disable-next-line no-console
            console.warn('DropShadowFilter now uses options instead of (rotation, distance, blur, color, alpha)');
            options = { rotation: options };
            if (arguments[1] !== undefined) {
                options.distance = arguments[1];
            }
            if (arguments[2] !== undefined) {
                options.blur = arguments[2];
            }
            if (arguments[3] !== undefined) {
                options.color = arguments[3];
            }
            if (arguments[4] !== undefined) {
                options.alpha = arguments[4];
            }
        }

        options = Object.assign({
            rotation: 45,
            distance: 5,
            color: 0x000000,
            alpha: 0.5,
            shadowOnly: false,
            kernels: null,
            blur: 2,
            quality: 3,
            pixelSize: 1,
            resolution: settings.settings.RESOLUTION,
        }, options);

        Filter.call(this);

        var kernels = options.kernels;
        var blur = options.blur;
        var quality = options.quality;
        var pixelSize = options.pixelSize;
        var resolution = options.resolution;

        this._tintFilter = new Filter(vertex, fragment);
        this._tintFilter.uniforms.color = new Float32Array(4);
        this._tintFilter.uniforms.shift = new math.Point();
        this._tintFilter.resolution = resolution;
        this._blurFilter = kernels ?
            new filterKawaseBlur.KawaseBlurFilter(kernels) :
            new filterKawaseBlur.KawaseBlurFilter(blur, quality);

        this.pixelSize = pixelSize;
        this.resolution = resolution;

        var shadowOnly = options.shadowOnly;
        var rotation = options.rotation;
        var distance = options.distance;
        var alpha = options.alpha;
        var color = options.color;

        this.shadowOnly = shadowOnly;
        this.rotation = rotation;
        this.distance = distance;
        this.alpha = alpha;
        this.color = color;

        this._updatePadding();
    }

    if ( Filter ) DropShadowFilter.__proto__ = Filter;
    DropShadowFilter.prototype = Object.create( Filter && Filter.prototype );
    DropShadowFilter.prototype.constructor = DropShadowFilter;

    var prototypeAccessors = { resolution: { configurable: true },distance: { configurable: true },rotation: { configurable: true },alpha: { configurable: true },color: { configurable: true },kernels: { configurable: true },blur: { configurable: true },quality: { configurable: true },pixelSize: { configurable: true } };

    DropShadowFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        var target = filterManager.getFilterTexture();

        this._tintFilter.apply(filterManager, input, target, true);
        this._blurFilter.apply(filterManager, target, output, clear);

        if (this.shadowOnly !== true) {
            filterManager.applyFilter(this, input, output, false);
        }

        filterManager.returnFilterTexture(target);
    };

    /**
     * Recalculate the proper padding amount.
     * @private
     */
    DropShadowFilter.prototype._updatePadding = function _updatePadding () {
        this.padding = this.distance + (this.blur * 2);
    };

    /**
     * Update the transform matrix of offset angle.
     * @private
     */
    DropShadowFilter.prototype._updateShift = function _updateShift () {
        this._tintFilter.uniforms.shift.set(
            this.distance * Math.cos(this.angle),
            this.distance * Math.sin(this.angle)
        );
    };

    /**
     * The resolution of the filter.
     *
     * @member {number}
     * @default PIXI.settings.RESOLUTION
     */
    prototypeAccessors.resolution.get = function () {
        return this._resolution;
    };
    prototypeAccessors.resolution.set = function (value) {
        this._resolution = value;

        if (this._tintFilter) {
            this._tintFilter.resolution = value;
        }
        if (this._blurFilter) {
            this._blurFilter.resolution = value;
        }
    };

    /**
     * Distance offset of the shadow
     * @member {number}
     * @default 5
     */
    prototypeAccessors.distance.get = function () {
        return this._distance;
    };
    prototypeAccessors.distance.set = function (value) {
        this._distance = value;
        this._updatePadding();
        this._updateShift();
    };

    /**
     * The angle of the shadow in degrees
     * @member {number}
     * @default 2
     */
    prototypeAccessors.rotation.get = function () {
        return this.angle / math.DEG_TO_RAD;
    };
    prototypeAccessors.rotation.set = function (value) {
        this.angle = value * math.DEG_TO_RAD;
        this._updateShift();
    };

    /**
     * The alpha of the shadow
     * @member {number}
     * @default 1
     */
    prototypeAccessors.alpha.get = function () {
        return this._tintFilter.uniforms.alpha;
    };
    prototypeAccessors.alpha.set = function (value) {
        this._tintFilter.uniforms.alpha = value;
    };

    /**
     * The color of the shadow.
     * @member {number}
     * @default 0x000000
     */
    prototypeAccessors.color.get = function () {
        return utils.rgb2hex(this._tintFilter.uniforms.color);
    };
    prototypeAccessors.color.set = function (value) {
        utils.hex2rgb(value, this._tintFilter.uniforms.color);
    };

    /**
     * Sets the kernels of the Blur Filter
     *
     * @member {number[]}
     */
    prototypeAccessors.kernels.get = function () {
        return this._blurFilter.kernels;
    };
    prototypeAccessors.kernels.set = function (value) {
        this._blurFilter.kernels = value;
    };

    /**
     * The blur of the shadow
     * @member {number}
     * @default 2
     */
    prototypeAccessors.blur.get = function () {
        return this._blurFilter.blur;
    };
    prototypeAccessors.blur.set = function (value) {
        this._blurFilter.blur = value;
        this._updatePadding();
    };

    /**
     * Sets the quality of the Blur Filter
     *
     * @member {number}
     * @default 4
     */
    prototypeAccessors.quality.get = function () {
        return this._blurFilter.quality;
    };
    prototypeAccessors.quality.set = function (value) {
        this._blurFilter.quality = value;
    };

    /**
     * Sets the pixelSize of the Kawase Blur filter
     *
     * @member {number|number[]|PIXI.Point}
     * @default 1
     */
    prototypeAccessors.pixelSize.get = function () {
        return this._blurFilter.pixelSize;
    };
    prototypeAccessors.pixelSize.set = function (value) {
        this._blurFilter.pixelSize = value;
    };

    Object.defineProperties( DropShadowFilter.prototype, prototypeAccessors );

    return DropShadowFilter;
}(core.Filter));

exports.DropShadowFilter = DropShadowFilter;
//# sourceMappingURL=filter-drop-shadow.cjs.js.map
