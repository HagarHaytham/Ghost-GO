{"version":3,"file":"graphics.min.js","sources":["../src/const.js","../src/styles/FillStyle.js","../src/GraphicsData.js","../src/utils/buildCircle.js","../src/utils/buildLine.js","../src/utils/buildPoly.js","../src/utils/buildRoundedRectangle.js","../src/GraphicsGeometry.js","../src/utils/buildRectangle.js","../src/styles/LineStyle.js","../src/utils/BezierUtils.js","../src/utils/QuadraticUtils.js","../src/utils/ArcUtils.js","../src/utils/Star.js","../src/Graphics.js"],"sourcesContent":["/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments: 2048,\n    _segmentsCount(length, defaultSegments = 20)\n    {\n        if (!this.adaptive)\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nexport default class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.FillStyle}\n     */\n    clone()\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /**\n     * Reset\n     */\n    reset()\n    {\n        /**\n         * The hex color value used when coloring the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.color = 0xFFFFFF;\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.alpha = 1;\n\n        /**\n         * The texture to be used for the fill.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.texture = Texture.WHITE;\n\n        /**\n         * The transform aplpied to the texture.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.matrix = null;\n\n        /**\n         * If the current fill is visible.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.visible = false;\n    }\n\n    /**\n     * Destroy and don't use after this\n     */\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nexport default class GraphicsData\n{\n    /**\n     *\n     * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n     * @param {PIXI.Matrix} [matrix] - Transform matrix\n     */\n    constructor(shape, fillStyle = null, lineStyle = null, matrix = null)\n    {\n        /**\n         * The shape object to draw.\n         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n         */\n        this.shape = shape;\n\n        /**\n         * The style of the line.\n         * @member {PIXI.LineStyle}\n         */\n        this.lineStyle = lineStyle;\n\n        /**\n         * The style of the fill.\n         * @member {PIXI.FillStyle}\n         */\n        this.fillStyle = fillStyle;\n\n        /**\n         * The transform matrix.\n         * @member {PIXI.Matrix}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The type of the shape, see the Const.Shapes file for all the existing types,\n         * @member {number}\n         */\n        this.type = shape.type;\n\n        /**\n         * The collection of points.\n         * @member {number[]}\n         */\n        this.points = [];\n\n        /**\n         * The collection of holes.\n         * @member {PIXI.GraphicsData[]}\n         */\n        this.holes = [];\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return {PIXI.GraphicsData} Cloned GraphicsData object\n     */\n    clone()\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /**\n     * Destroys the Graphics data.\n     */\n    destroy()\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import { SHAPES } from '@pixi/math';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport default {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n\n        points.length = 0;\n\n        // TODO - bit hacky??\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            width = circleData.width;\n            height = circleData.height;\n        }\n\n        if (width === 0 || height === 0)\n        {\n            return;\n        }\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n\n        totalSegs /= 2.3;\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n\n        points.push(\n            points[0],\n            points[1]\n        );\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        verts.push(graphicsData.shape.x, graphicsData.shape.y);\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n    },\n};\n","import { Point, SHAPES } from '@pixi/math';\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport default function (graphicsData, graphicsGeometry)\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildLine(graphicsData, graphicsGeometry);\n    }\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildLine(graphicsData, graphicsGeometry)\n{\n    const shape = graphicsData.shape;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);\n        const midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    let indexStart = verts.length / 2;\n\n    // DRAW the Line\n    const width = style.width / 2;\n\n    // sort color\n    let p1x = points[0];\n    let p1y = points[1];\n    let p2x = points[2];\n    let p2y = points[3];\n    let p3x = 0;\n    let p3y = 0;\n\n    let perpx = -(p1y - p2y);\n    let perpy = p1x - p2x;\n    let perp2x = 0;\n    let perp2y = 0;\n    let perp3x = 0;\n    let perp3y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const r1 = (1 - ratio) * 2;\n    const r2 = ratio * 2;\n\n    // start\n    verts.push(\n        p1x - (perpx * r1),\n        p1y - (perpy * r1));\n\n    verts.push(\n        p1x + (perpx * r2),\n        p1y + (perpy * r2));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        p1x = points[(i - 1) * 2];\n        p1y = points[((i - 1) * 2) + 1];\n\n        p2x = points[i * 2];\n        p2y = points[(i * 2) + 1];\n\n        p3x = points[(i + 1) * 2];\n        p3y = points[((i + 1) * 2) + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        const a1 = (-perpy + p1y) - (-perpy + p2y);\n        const b1 = (-perpx + p2x) - (-perpx + p1x);\n        const c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));\n        const a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        const b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        const c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));\n\n        let denom = (a1 * b2) - (a2 * b1);\n\n        if (Math.abs(denom) < 0.1)\n        {\n            denom += 10.1;\n            verts.push(\n                p2x - (perpx * r1),\n                p2y - (perpy * r1));\n\n            verts.push(\n                p2x + (perpx * r2),\n                p2y + (perpy * r2));\n\n            continue;\n        }\n\n        const px = ((b1 * c2) - (b2 * c1)) / denom;\n        const py = ((a2 * c1) - (a1 * c2)) / denom;\n        const pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));\n\n        if (pdist > (196 * width * width))\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));\n\n            verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));\n\n            verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));\n\n            indexCount++;\n        }\n        else\n        {\n            verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));\n\n            verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));\n        }\n    }\n\n    p1x = points[(length - 2) * 2];\n    p1y = points[((length - 2) * 2) + 1];\n\n    p2x = points[(length - 1) * 2];\n    p2y = points[((length - 1) * 2) + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - (perpx * r1), p2y - (perpy * r1));\n\n    verts.push(p2x + (perpx * r2), p2y + (perpy * r2));\n\n    const indices = graphicsGeometry.indices;\n\n    // indices.push(indexStart);\n\n    for (let i = 0; i < indexCount - 2; ++i)\n    {\n        indices.push(indexStart, indexStart + 1, indexStart + 2);\n\n        indexStart++;\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry)\n{\n    let i = 0;\n\n    const shape = graphicsData.shape;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport default {\n\n    build(graphicsData)\n    {\n        graphicsData.points = graphicsData.shape.points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport default {\n\n    build(graphicsData)\n    {\n        const rrectData = graphicsData.shape;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        const radius = rrectData.radius;\n\n        points.length = 0;\n\n        quadraticBezierCurve(x, y + radius,\n            x, y,\n            x + radius, y,\n            points);\n        quadraticBezierCurve(x + width - radius,\n            y, x + width, y,\n            x + width, y + radius,\n            points);\n        quadraticBezierCurve(x + width, y + height - radius,\n            x + width, y + height,\n            x + width - radius, y + height,\n            points);\n        quadraticBezierCurve(x + radius, y + height,\n            x, y + height,\n            x, y + height - radius,\n            points);\n\n        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n        // TODO - fix this properly, this is not very elegant.. but it works for now.\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc)\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n","import { SHAPES, Point } from '@pixi/math';\nimport { Bounds } from '@pixi/display';\nimport { BatchGeometry, BatchDrawCall, BaseTexture } from '@pixi/core';\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\n\nimport GraphicsData from './GraphicsData';\nimport buildCircle from './utils/buildCircle';\nimport buildLine from './utils/buildLine';\nimport buildPoly from './utils/buildPoly';\nimport buildRectangle from './utils/buildRectangle';\nimport buildRoundedRectangle from './utils/buildRoundedRectangle';\nimport { premultiplyTint } from '@pixi/utils';\n\nconst BATCH_POOL = [];\nconst DRAW_CALL_POOL = [];\nconst tmpPoint = new Point();\n\n/**\n * Map of fill commands for each shape type.\n *\n * @member {Object}\n * @private\n */\nconst fillCommands = {};\n\nfillCommands[SHAPES.POLY] = buildPoly;\nfillCommands[SHAPES.CIRC] = buildCircle;\nfillCommands[SHAPES.ELIP] = buildCircle;\nfillCommands[SHAPES.RECT] = buildRectangle;\nfillCommands[SHAPES.RREC] = buildRoundedRectangle;\n\n/**\n * A little internal structure to hold interim batch objects.\n *\n * @private\n */\nclass BatchPart\n{\n    constructor()\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nexport default class GraphicsGeometry extends BatchGeometry\n{\n    constructor()\n    {\n        super();\n\n        /**\n         * An array of points to draw, 2 numbers per point\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.points = [];\n\n        /**\n         * The collection of colors\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.colors = [];\n\n        /**\n         * The UVs collection\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.uvs = [];\n\n        /**\n         * The indices of the vertices\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.indices = [];\n\n        /**\n         * Reference to the texture IDs.\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.textureIds = [];\n\n        /**\n         * The collection of drawn shapes.\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @protected\n         */\n        this.graphicsData = [];\n\n        /**\n         * Used to detect if the graphics object has changed.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.dirty = 0;\n\n        /**\n         * Batches need to regenerated if the geometry is updated.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.batchDirty = -1;\n\n        /**\n         * Used to check if the cache is dirty.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.cacheDirty = -1;\n\n        /**\n         * Used to detect if we cleared the graphicsData.\n         *\n         * @member {number}\n         * @default 0\n         * @protected\n         */\n        this.clearDirty = 0;\n\n        /**\n         * List of current draw calls drived from the batches.\n         *\n         * @member {object[]}\n         * @protected\n         */\n        this.drawCalls = [];\n\n        /**\n         * Intermediate abstract format sent to batch system.\n         * Can be converted to drawCalls or to batchable objects.\n         *\n         * @member {object[]}\n         * @protected\n         */\n        this.batches = [];\n\n        /**\n         * Index of the last batched shape in the stack of calls.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.shapeIndex = 0;\n\n        /**\n         * Cached bounds.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._bounds = new Bounds();\n\n        /**\n         * The bounds dirty flag.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Padding to add to the bounds.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.uvsFloat32 = null;\n\n        /**\n         * Minimal distance between points that are considered different.\n         * Affects line tesselation.\n         *\n         * @member {number}\n         */\n        this.closePointEps = 1e-4;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    get bounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    invalidate()\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batch =  this.batches[i];\n\n            batch.start = 0;\n            batch.attribStart = 0;\n            batch.style = null;\n            BATCH_POOL.push(batch);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawShape(shape, fillStyle, lineStyle, matrix)\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    drawHole(shape, matrix)\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.Point} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    containsPoint(point)\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                return false;\n                            }\n                        }\n                    }\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches()\n    {\n        if (this.dirty === this.cacheDirty) return;\n        if (this.graphicsData.length === 0)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (this.dirty !== this.cacheDirty)\n        {\n            for (let i = 0; i < this.graphicsData.length; i++)\n            {\n                const data = this.graphicsData[i];\n\n                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) return;\n                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) return;\n            }\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n\n        let batchPart = null;\n        let currentTexture = null;\n        let currentColor = 0;\n        let currentNative = false;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n\n            const style = batchPart.style;\n\n            currentTexture = style.texture.baseTexture;\n            currentColor = style.color + style.alpha;\n            currentNative = !!style.native;\n        }\n\n        for (let i = this.shapeIndex; i < this.graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = this.graphicsData[i];\n            const command = fillCommands[data.type];\n\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                // close batch if style is different\n                if (batchPart\n                    && (currentTexture !== nextTexture\n                    || currentColor !== (style.color + style.alpha)\n                    || currentNative !== !!style.native))\n                {\n                    batchPart.size = index - batchPart.start;\n                    batchPart.attribSize = attribIndex - batchPart.attribStart;\n\n                    if (batchPart.size > 0)\n                    {\n                        batchPart = null;\n                    }\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    this.batches.push(batchPart);\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n                    currentTexture = nextTexture;\n                    currentColor = style.color + style.alpha;\n                    currentNative = style.native;\n\n                    batchPart.style = style;\n                    batchPart.start = index;\n                    batchPart.attribStart = attribIndex;\n                }\n\n                const start = this.points.length / 2;\n\n                if (j === 0)\n                {\n                    if (data.holes.length)\n                    {\n                        this.processHoles(data.holes);\n\n                        buildPoly.triangulate(data, this);\n                    }\n                    else\n                    {\n                        command.triangulate(data, this);\n                    }\n                }\n                else\n                {\n                    buildLine(data, this);\n\n                    for (let i = 0; i < data.holes.length; i++)\n                    {\n                        buildLine(data.holes[i], this);\n                    }\n                }\n\n                const size = (this.points.length / 2) - start;\n\n                this.addUvs(this.points, uvs, style.texture, start, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (!batchPart)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        batchPart.size = index - batchPart.start;\n        batchPart.attribSize = attrib - batchPart.attribStart;\n        this.indicesUint16 = new Uint16Array(this.indices);\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.batchDirty++;\n\n            this.uvsFloat32 = new Float32Array(this.uvs);\n\n            // offset the indices so that it works with the batcher...\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                for (let j = 0; j < batch.size; j++)\n                {\n                    const index = batch.start + j;\n\n                    this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n                }\n            }\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     * @protected\n     */\n    isBatchable()\n    {\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if (batches[i].style.native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     * @protected\n     */\n    buildDrawCalls()\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].textures.length = 0;\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup =  DRAW_CALL_POOL.pop() || new BatchDrawCall();\n\n        currentGroup.textureCount = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            const style = data.style;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.textureCount = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    nextTexture.touched = 1;// touch;\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._id = textureCount;\n                    nextTexture.wrapMode = 10497;\n\n                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._id;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize);\n            this.addTextureIds(textureIds, textureId, data.attribSize);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        const verts = this.points;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process the holes data.\n     *\n     * @param {PIXI.GraphicsData[]} holes - Holes to render\n     * @protected\n     */\n    processHoles(holes)\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            const command = fillCommands[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     * @protected\n     */\n    calculateBounds()\n    {\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        if (this.graphicsData.length)\n        {\n            let shape = null;\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            for (let i = 0; i < this.graphicsData.length; i++)\n            {\n                const data = this.graphicsData[i];\n\n                const type = data.type;\n                const lineWidth = data.lineStyle ? data.lineStyle.width : 0;\n\n                shape = data.shape;\n\n                if (type === SHAPES.RECT || type === SHAPES.RREC)\n                {\n                    x = shape.x - (lineWidth / 2);\n                    y = shape.y - (lineWidth / 2);\n                    w = shape.width + lineWidth;\n                    h = shape.height + lineWidth;\n\n                    minX = x < minX ? x : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y < minY ? y : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.CIRC)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.radius + (lineWidth / 2);\n                    h = shape.radius + (lineWidth / 2);\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.ELIP)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.width + (lineWidth / 2);\n                    h = shape.height + (lineWidth / 2);\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else\n                {\n                    // POLY\n                    const points = shape.points;\n                    let x2 = 0;\n                    let y2 = 0;\n                    let dx = 0;\n                    let dy = 0;\n                    let rw = 0;\n                    let rh = 0;\n                    let cx = 0;\n                    let cy = 0;\n\n                    for (let j = 0; j + 2 < points.length; j += 2)\n                    {\n                        x = points[j];\n                        y = points[j + 1];\n                        x2 = points[j + 2];\n                        y2 = points[j + 3];\n                        dx = Math.abs(x2 - x);\n                        dy = Math.abs(y2 - y);\n                        h = lineWidth;\n                        w = Math.sqrt((dx * dx) + (dy * dy));\n\n                        if (w < 1e-9)\n                        {\n                            continue;\n                        }\n\n                        rw = ((h / w * dy) + dx) / 2;\n                        rh = ((h / w * dx) + dy) / 2;\n                        cx = (x2 + x) / 2;\n                        cy = (y2 + y) / 2;\n\n                        minX = cx - rw < minX ? cx - rw : minX;\n                        maxX = cx + rw > maxX ? cx + rw : maxX;\n\n                        minY = cy - rh < minY ? cy - rh : minY;\n                        maxY = cy + rh > maxY ? cy + rh : maxY;\n                    }\n                }\n            }\n        }\n        else\n        {\n            minX = 0;\n            maxX = 0;\n            minY = 0;\n            maxY = 0;\n        }\n\n        const padding = this.boundsPadding;\n\n        this._bounds.minX = minX - padding;\n        this._bounds.maxX = maxX + padding;\n\n        this._bounds.minY = minY - padding;\n        this._bounds.maxY = maxY + padding;\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    transformPoints(points, matrix)\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @protected\n     * @param {number[]} colors - List of colors to add to\n     * @param {number} color - Color to add\n     * @param {number} alpha - Alpha to use\n     * @param {number} size - Number of colors to add\n     */\n    addColors(colors, color, alpha, size)\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        while (size-- > 0)\n        {\n            colors.push(rgba);\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     *\n     * @protected\n     * @param {number[]} textureIds\n     * @param {number} id\n     * @param {number} size\n     */\n    addTextureIds(textureIds, id, size)\n    {\n        while (size-- > 0)\n        {\n            textureIds.push(id);\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @protected\n     * @param {number[]} verts - Vertices\n     * @param {number[]} uvs - UVs\n     * @param {PIXI.Texture} texture - Reference to Texture\n     * @param {number} start - Index buffer start index.\n     * @param {number} size - The size/length for index buffer.\n     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n     */\n    addUvs(verts, uvs, texture, start, size, matrix)\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param {number[]} uvs array\n     * @param {PIXI.Texture} texture region\n     * @param {number} start starting index for uvs\n     * @param {number} size how many points to adjust\n     */\n    adjustUvs(uvs, texture, start, size)\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n\n/**\n * The maximum number of points to consider an object \"batchable\",\n * able to be batched by the renderer's batch system.\n *\n * @memberof PIXI.GraphicsGeometry\n * @static\n * @member {number} BATCHABLE_SIZE\n * @default 100\n */\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n","/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport default {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import FillStyle from './FillStyle';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nexport default class LineStyle extends FillStyle\n{\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.LineStyle}\n     */\n    clone()\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n\n        return obj;\n    }\n    /**\n     * Reset the line style to default.\n     */\n    reset()\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.width = 0;\n\n        /**\n         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.alignment = 0.5;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.native = false;\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nexport default class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Path array to push points into\n     */\n    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nexport default class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    static curveLength(fromX, fromY, cpX, cpY, toX, toY)\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Points to add segments to.\n     */\n    static curveTo(cpX, cpY, toX, toY, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nexport default class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1, y1, x2, y2, radius, points)\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param {number} startX - Start x location of arc\n     * @param {number} startY - Start y location of arc\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param {number} n - Number of segments\n     * @param {number[]} points - Collection of points to add to\n     */\n    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points)\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n}\n","import { Polygon, PI_2 } from '@pixi/math';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport default class Star extends Polygon\n{\n    constructor(x, y, points, radius, innerRadius, rotation)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n} from '@pixi/math';\nimport { hex2rgb } from '@pixi/utils';\nimport {\n    Texture,\n    Shader,\n    UniformGroup, State,\n} from '@pixi/core';\nimport FillStyle from './styles/FillStyle';\nimport GraphicsGeometry from './GraphicsGeometry';\nimport LineStyle from './styles/LineStyle';\nimport BezierUtils from './utils/BezierUtils';\nimport QuadraticUtils from './utils/QuadraticUtils';\nimport ArcUtils from './utils/ArcUtils';\nimport Star from './utils/Star';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS = {};\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport default class Graphics extends Container\n{\n    /**\n     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n     *        will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry = null)\n    {\n        super();\n        /**\n         * Includes vertex positions, face indices, normals, colors, UVs, and\n         * custom attributes within buffers, reducing the cost of passing all\n         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n         * @member {PIXI.GraphicsGeometry}\n         * @readonly\n         */\n        this.geometry = geometry || new GraphicsGeometry();\n\n        this.geometry.refCount++;\n\n        /**\n         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n         * Can be shared between multiple Graphics objects.\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n         * @member {PIXI.State}\n         */\n        this.state = State.for2d();\n\n        /**\n         * Current fill style\n         *\n         * @member {PIXI.FillStyle}\n         * @protected\n         */\n        this._fillStyle = new FillStyle();\n\n        /**\n         * Current line style\n         *\n         * @member {PIXI.LineStyle}\n         * @protected\n         */\n        this._lineStyle = new LineStyle();\n\n        /**\n         * Current shape transform matrix.\n         *\n         * @member {PIXI.Matrix}\n         * @protected\n         */\n        this._matrix = null;\n\n        /**\n         * Current hole mode is enabled.\n         *\n         * @member {boolean}\n         * @default false\n         * @protected\n         */\n        this._holeMode = false;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.Polygon}\n         * @protected\n         */\n        this.currentPath = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        /**\n         * A collections of batches! These can be drawn by the renderer batch system.\n         *\n         * @protected\n         * @member {object[]}\n         */\n        this.batches = [];\n\n        /**\n         * Update dirty for limiting calculating tints for batches.\n         *\n         * @protected\n         * @member {number}\n         * @default -1\n         */\n        this.batchTint = -1;\n\n        /**\n         * Copy of the object vertex data.\n         *\n         * @protected\n         * @member {Float32Array}\n         */\n        this.vertexData = null;\n\n        this._transformID = -1;\n        this.batchDirty = -1;\n\n        /**\n         * Renderer plugin for batching\n         *\n         * @member {string}\n         * @default 'batch'\n         */\n        this.pluginName = 'batch';\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        this.finishPoly();\n\n        return new Graphics(this.geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    set blendMode(value)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode()\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n    set tint(value)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    get fill()\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    get line()\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(width = 0, color = 0, alpha = 1, alignment = 0.5, native = false)\n    {\n        this.lineTextureStyle(width, Texture.WHITE, color, alpha, null, alignment, native);\n\n        return this;\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTextureStyle(width = 0, texture = Texture.WHITE, color = 0xFFFFFF, alpha = 1,\n        matrix = null, alignment = 0.5, native = false)\n    {\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = width > 0 && alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (matrix)\n            {\n                matrix = matrix.clone();\n                matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, {\n                color,\n                width,\n                alpha,\n                matrix,\n                texture,\n                alignment,\n                native,\n                visible,\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally\n     * @protected\n     */\n    startPoly()\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly()\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     *\n     * @protected\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     */\n    _initCurve(x = 0, y = 0)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n     * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this.geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        return this.beginTextureFill(Texture.WHITE, color, alpha);\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [color=0xffffff] - Background to fill behind texture\n     * @param {number} [alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(texture = Texture.WHITE, color = 0xFFFFFF, alpha = 1, matrix = null)\n    {\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (matrix)\n            {\n                matrix = matrix.clone();\n                matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, {\n                color,\n                alpha,\n                texture,\n                matrix,\n                visible,\n            });\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closeStroke = true;// !!this._fillStyle;\n\n        // check if data has points..\n        if (points.points)\n        {\n            closeStroke = points.closeStroke;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawShape(shape)\n    {\n        if (!this._holeMode)\n        {\n            this.geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this.geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an arbitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawStar(x, y, points, radius, innerRadius, rotation = 0)\n    {\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        this.geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        // will fix this!\n        return false;\n        // this.graphicsData.length === 1\n        //  && this.graphicsData[0].shape.type === SHAPES.RECT\n        // && !this.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _render(renderer)\n    {\n        this.finishPoly();\n\n        const geometry = this.geometry;\n\n        // batch part..\n        // batch it!\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /**\n     * Populating batches for rendering\n     *\n     * @protected\n     */\n    _populateBatches()\n    {\n        const geometry = this.geometry;\n        const blendMode = this.blendMode;\n\n        this.batches = [];\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0, l = geometry.batches.length; i < l; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color),\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderBatched(renderer)\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _renderDirect(renderer)\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this.geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     *\n     * @param {PIXI.Renderer} renderer\n     * @param {PIXI.BatchDrawCall} drawCall\n     */\n    _renderDrawCallDirect(renderer, drawCall)\n    {\n        const groupTextureCount = drawCall.textureCount;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(drawCall.textures[j], j);\n        }\n\n        renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _resolveDirectShader(renderer)\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const sampleValues = new Int32Array(16);\n\n                for (let i = 0; i < 16; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @protected\n     */\n    _calculateBounds()\n    {\n        this.finishPoly();\n        const lb = this.geometry.bounds;\n\n        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this.geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /**\n     * Recalcuate the tint by applying tin to batches using Graphics tint.\n     * @protected\n     */\n    calculateTints()\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recaculate the vertices.\n     * @protected\n     */\n    calculateVertices()\n    {\n        if (this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this.geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    setMatrix(matrix)\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    beginHole()\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    endHole()\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.geometry.refCount--;\n        if (this.geometry.refCount === 0)\n        {\n            this.geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this.geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Temporary point to use for containsPoint\n *\n * @static\n * @private\n * @member {PIXI.Point}\n */\nGraphics._TEMP_POINT = new Point();\n"],"names":["GRAPHICS_CURVES","adaptive","maxLength","minSegments","maxSegments","_segmentsCount","length","defaultSegments","this","let","result","Math","ceil","FillStyle","reset","clone","const","obj","color","alpha","texture","matrix","visible","Texture","WHITE","destroy","GraphicsData","shape","fillStyle","lineStyle","type","points","holes","build","graphicsData","width","height","circleData","x","y","SHAPES","CIRC","radius","totalSegs","floor","sqrt","seg","PI","i","push","sin","cos","triangulate","graphicsGeometry","verts","indices","vertPos","center","native","closedShape","POLY","closeStroke","startIndex","currentIndex","buildNativeLine","slice","eps","closePointEps","style","firstPoint","Point","lastPoint","closedPath","abs","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","p1x","p1y","p2x","p2y","p3x","p3y","perpx","perpy","perp2x","perp2y","perp3x","perp3y","dist","ratio","alignment","r1","r2","a1","b1","c1","a2","b2","c2","denom","px","py","pdist","buildLine","holeArray","hole","concat","triangles","earcut","rrectData","quadraticBezierCurve","vecPos","j","getPt","n1","n2","perc","fromX","fromY","cpX","cpY","toX","toY","out","xa","ya","xb","yb","BATCH_POOL","DRAW_CALL_POOL","tmpPoint","fillCommands","buildPoly","buildCircle","ELIP","RECT","rectData","RREC","buildRoundedRectangle","BatchPart","size","start","attribStart","attribSize","GraphicsGeometry","super","colors","uvs","textureIds","dirty","batchDirty","cacheDirty","clearDirty","drawCalls","batches","shapeIndex","_bounds","Bounds","boundsDirty","boundsPadding","batchable","indicesUint16","uvsFloat32","prototypeAccessors","bounds","calculateBounds","invalidate","textures","batch","clear","drawShape","data","drawHole","lastShape","options","indexBuffer","containsPoint","point","applyInverse","copyFrom","contains","updateBatches","baseTexture","valid","batchPart","currentTexture","currentColor","currentNative","command","transformPoints","nextTexture","index","attribIndex","wrapMode","WRAP_MODES","REPEAT","processHoles","addUvs","attrib","Uint16Array","isBatchable","Float32Array","buildDrawCalls","BATCHABLE_SIZE","TICK","BaseTexture","_globalBatch","currentGroup","BatchDrawCall","textureCount","DRAW_MODES","TRIANGLES","textureId","drawMode","LINES","_batchEnabled","touched","_id","addColors","addTextureIds","glPoints","ArrayBuffer","f32","u32","Uint32Array","p","_buffer","update","_indexBuffer","minX","Infinity","maxX","minY","maxY","w","h","lineWidth","x2","y2","dx","dy","rw","rh","cx","cy","padding","a","c","tx","b","d","ty","rgb","rgba","premultiplyTint","id","uvsStart","frame","nx","adjustUvs","finish","scaleX","scaleY","offsetX","offsetY","min","BatchGeometry","LineStyle","BezierUtils","curveLength","cpX2","cpY2","t","t2","t3","nt","nt2","nt3","prevX","prevY","curveTo","n","dt","dt2","dt3","QuadraticUtils","ax","ay","bx","by","s","a32","ba","log","ArcUtils","x1","y1","mm","dd","cc","tt","k1","k2","j1","j2","qx","qy","startAngle","atan2","endAngle","anticlockwise","arc","startX","startY","sweep","PI_2","theta","theta2","cTheta","sTheta","segMinus","remainder","angle","Star","innerRadius","rotation","len","delta","polygon","r","Polygon","temp","DEFAULT_SHADERS","Graphics","geometry","refCount","shader","state","State","for2d","_fillStyle","_lineStyle","_matrix","_holeMode","currentPath","batchTint","vertexData","_transformID","pluginName","tint","blendMode","BLEND_MODES","NORMAL","finishPoly","value","_tint","fill","line","lineTextureStyle","startPoly","invert","Object","assign","moveTo","lineTo","_initCurve","quadraticCurveTo","bezierCurveTo","arcTo","xDiff","yDiff","beginFill","beginTextureFill","endFill","drawRect","Rectangle","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","Array","isArray","arguments","drawStar","isFastRect","_render","renderer","_populateBatches","_renderBatched","flush","_renderDirect","l","gI","buffer","_batchRGB","hex2rgb","_tintRGB","_texture","worldAlpha","setObjectRenderer","plugins","calculateVertices","calculateTints","render","_resolveDirectShader","uniforms","translationMatrix","transform","worldTransform","bind","_renderDrawCallDirect","drawCall","groupTextureCount","draw","sampleValues","Int32Array","Matrix","default","UniformGroup","from","uSamplers","program","_shader","Shader","_calculateBounds","lb","addFrame","_TEMP_POINT","tintRGB","_worldID","wt","count","closePath","setMatrix","beginHole","endHole","dispose","Container"],"mappings":"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"}