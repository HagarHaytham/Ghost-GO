/*!
 * @pixi/filter-color-map - v3.0.3
 * Compiled Wed, 29 May 2019 03:04:05 UTC
 *
 * @pixi/filter-color-map is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
import { Texture, Filter } from '@pixi/core';
import { SCALE_MODES } from '@pixi/constants';

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}";

/**
 * The ColorMapFilter applies a color-map effect to an object.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/color-map.png)
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-color-map|@pixi/filter-color-map}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 * @param {HTMLImageElement|HTMLCanvasElement|PIXI.BaseTexture|PIXI.Texture} [colorMap] - The colorMap texture of the filter.
 * @param {boolean} [nearest=false] - Whether use NEAREST for colorMap texture.
 * @param {number} [mix=1] - The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.
 */
var ColorMapFilter = /*@__PURE__*/(function (Filter) {
    function ColorMapFilter(colorMap, nearest, mix) {
        if ( nearest === void 0 ) nearest = false;
        if ( mix === void 0 ) mix = 1;

        Filter.call(this, vertex, fragment);

        this._size = 0;
        this._sliceSize = 0;
        this._slicePixelSize = 0;
        this._sliceInnerSize = 0;

        this._scaleMode = null;
        this._nearest = false;
        this.nearest = nearest;

        /**
         * The mix from 0 to 1, where 0 is the original image and 1 is the color mapped image.
         * @member {number}
         */
        this.mix = mix;

        this.colorMap = colorMap;
    }

    if ( Filter ) ColorMapFilter.__proto__ = Filter;
    ColorMapFilter.prototype = Object.create( Filter && Filter.prototype );
    ColorMapFilter.prototype.constructor = ColorMapFilter;

    var prototypeAccessors = { colorSize: { configurable: true },colorMap: { configurable: true },nearest: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    ColorMapFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms._mix = this.mix;

        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * the size of one color slice
     * @member {number}
     * @readonly
     */
    prototypeAccessors.colorSize.get = function () {
        return this._size;
    };

    /**
     * the colorMap texture
     * @member {PIXI.Texture}
     */
    prototypeAccessors.colorMap.get = function () {
        return this._colorMap;
    };
    prototypeAccessors.colorMap.set = function (colorMap) {
        if (!(colorMap instanceof Texture)) {
            colorMap = Texture.from(colorMap);
        }
        if (colorMap && colorMap.baseTexture) {
            colorMap.baseTexture.scaleMode = this._scaleMode;
            colorMap.baseTexture.mipmap = false;

            this._size = colorMap.height;
            this._sliceSize = 1 / this._size;
            this._slicePixelSize = this._sliceSize / this._size;
            this._sliceInnerSize = this._slicePixelSize * (this._size - 1);

            this.uniforms._size = this._size;
            this.uniforms._sliceSize = this._sliceSize;
            this.uniforms._slicePixelSize = this._slicePixelSize;
            this.uniforms._sliceInnerSize = this._sliceInnerSize;

            this.uniforms.colorMap = colorMap;
        }

        this._colorMap = colorMap;
    };

    /**
     * Whether use NEAREST for colorMap texture.
     * @member {boolean}
     */
    prototypeAccessors.nearest.get = function () {
        return this._nearest;
    };
    prototypeAccessors.nearest.set = function (nearest) {
        this._nearest = nearest;
        this._scaleMode = nearest ? SCALE_MODES.NEAREST : SCALE_MODES.LINEAR;

        var texture = this._colorMap;

        if (texture && texture.baseTexture) {
            texture.baseTexture._glTextures = {};

            texture.baseTexture.scaleMode = this._scaleMode;
            texture.baseTexture.mipmap = false;

            texture._updateID++;
            texture.baseTexture.emit('update', texture.baseTexture);
        }
    };

    /**
     * If the colorMap is based on canvas , and the content of canvas has changed,
     *   then call `updateColorMap` for update texture.
     */
    ColorMapFilter.prototype.updateColorMap = function updateColorMap () {
        var texture = this._colorMap;

        if (texture && texture.baseTexture) {
            texture._updateID++;
            texture.baseTexture.emit('update', texture.baseTexture);

            this.colorMap = texture;
        }
    };

    /**
     * Destroys this filter
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture of colorMap as well
     */
    ColorMapFilter.prototype.destroy = function destroy (destroyBase) {
        if (this._colorMap) {
            this._colorMap.destroy(destroyBase);
        }
        Filter.prototype.destroy.call(this);
    };

    Object.defineProperties( ColorMapFilter.prototype, prototypeAccessors );

    return ColorMapFilter;
}(Filter));

export { ColorMapFilter };
//# sourceMappingURL=filter-color-map.esm.js.map
