/*!
 * @pixi/filter-crt - v3.0.3
 * Compiled Wed, 29 May 2019 03:04:05 UTC
 *
 * @pixi/filter-crt is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@pixi/core');

var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";

var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    vec2 dir = vec2(coord - vec2(0.5, 0.5));\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0) {\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n";

/**
 * The CRTFilter applies a CRT effect to an object.<br>
 * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/crt.gif)
 *
 * @class
 * @extends PIXI.Filter
 * @memberof PIXI.filters
 * @see {@link https://www.npmjs.com/package/@pixi/filter-crt|@pixi/filter-crt}
 * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}
 *
 * @param {object} [options] - The optional parameters of CRT effect
 * @param {number} [options.curvature=1.0] - Bent of interlaced lines, higher value means more bend
 * @param {number} [options.lineWidth=1.0] - Width of the interlaced lines
 * @param {number} [options.lineContrast=0.25] - Contrast of interlaced lines
 * @param {number} [options.verticalLine=false] - `true` is vertical lines, `false` is horizontal
 * @param {number} [options.noise=0.3] - Opacity/intensity of the noise effect between `0` and `1`
 * @param {number} [options.noiseSize=1.0] - The size of the noise particles
 * @param {number} [options.seed=0] - A seed value to apply to the random noise generation
 * @param {number} [options.vignetting=0.3] - The radius of the vignette effect, smaller
 *        values produces a smaller vignette
 * @param {number} [options.vignettingAlpha=1.0] - Amount of opacity of vignette
 * @param {number} [options.vignettingBlur=0.3] - Blur intensity of the vignette
 * @param {number} [options.time=0] - For animating interlaced lines
 */
var CRTFilter = /*@__PURE__*/(function (Filter) {
    function CRTFilter(options) {
        Filter.call(this, vertex, fragment);
        this.uniforms.dimensions = new Float32Array(2);

        /**
         * For animating interlaced lines
         *
         * @member {number}
         * @default 0
         */
        this.time = 0;

        /**
         * A seed value to apply to the random noise generation
         *
         * @member {number}
         * @default 0
         */
        this.seed = 0;

        Object.assign(this, {
            curvature: 1.0,
            lineWidth: 1.0,
            lineContrast: 0.25,
            verticalLine: false,
            noise: 0.0,
            noiseSize: 1.0,
            seed: 0.0,
            vignetting: 0.3,
            vignettingAlpha: 1.0,
            vignettingBlur: 0.3,
            time: 0.0,
        }, options);
    }

    if ( Filter ) CRTFilter.__proto__ = Filter;
    CRTFilter.prototype = Object.create( Filter && Filter.prototype );
    CRTFilter.prototype.constructor = CRTFilter;

    var prototypeAccessors = { curvature: { configurable: true },lineWidth: { configurable: true },lineContrast: { configurable: true },verticalLine: { configurable: true },noise: { configurable: true },noiseSize: { configurable: true },vignetting: { configurable: true },vignettingAlpha: { configurable: true },vignettingBlur: { configurable: true } };

    /**
     * Override existing apply method in PIXI.Filter
     * @private
     */
    CRTFilter.prototype.apply = function apply (filterManager, input, output, clear) {
        this.uniforms.dimensions[0] = input.filterFrame.width;
        this.uniforms.dimensions[1] = input.filterFrame.height;

        this.uniforms.seed = this.seed;
        this.uniforms.time = this.time;

        filterManager.applyFilter(this, input, output, clear);
    };

    /**
     * Bent of interlaced lines, higher value means more bend
     *
     * @member {number}
     * @default 1
     */
    prototypeAccessors.curvature.set = function (value) {
        this.uniforms.curvature = value;
    };
    prototypeAccessors.curvature.get = function () {
        return this.uniforms.curvature;
    };

    /**
     * Width of interlaced lines
     *
     * @member {number}
     * @default 1
     */
    prototypeAccessors.lineWidth.set = function (value) {
        this.uniforms.lineWidth = value;
    };
    prototypeAccessors.lineWidth.get = function () {
        return this.uniforms.lineWidth;
    };

    /**
     * Contrast of interlaced lines
     *
     * @member {number}
     * @default 0.25
     */
    prototypeAccessors.lineContrast.set = function (value) {
        this.uniforms.lineContrast = value;
    };
    prototypeAccessors.lineContrast.get = function () {
        return this.uniforms.lineContrast;
    };

    /**
     * `true` for vertical lines, `false` for horizontal lines
     *
     * @member {boolean}
     * @default false
     */
    prototypeAccessors.verticalLine.set = function (value) {
        this.uniforms.verticalLine = value;
    };
    prototypeAccessors.verticalLine.get = function () {
        return this.uniforms.verticalLine;
    };

    /**
     * Opacity/intensity of the noise effect between `0` and `1`
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.noise.set = function (value) {
        this.uniforms.noise = value;
    };
    prototypeAccessors.noise.get = function () {
        return this.uniforms.noise;
    };

    /**
     * The size of the noise particles
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.noiseSize.set = function (value) {
        this.uniforms.noiseSize = value;
    };
    prototypeAccessors.noiseSize.get = function () {
        return this.uniforms.noiseSize;
    };

    /**
     * The radius of the vignette effect, smaller
     * values produces a smaller vignette
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.vignetting.set = function (value) {
        this.uniforms.vignetting = value;
    };
    prototypeAccessors.vignetting.get = function () {
        return this.uniforms.vignetting;
    };

    /**
     * Amount of opacity of vignette
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.vignettingAlpha.set = function (value) {
        this.uniforms.vignettingAlpha = value;
    };
    prototypeAccessors.vignettingAlpha.get = function () {
        return this.uniforms.vignettingAlpha;
    };

    /**
     * Blur intensity of the vignette
     *
     * @member {number}
     * @default 0
     */
    prototypeAccessors.vignettingBlur.set = function (value) {
        this.uniforms.vignettingBlur = value;
    };
    prototypeAccessors.vignettingBlur.get = function () {
        return this.uniforms.vignettingBlur;
    };

    Object.defineProperties( CRTFilter.prototype, prototypeAccessors );

    return CRTFilter;
}(core.Filter));

exports.CRTFilter = CRTFilter;
//# sourceMappingURL=filter-crt.cjs.js.map
